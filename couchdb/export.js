{
    "_id": "_design/export",
    "views": {
        "ris": {
            "map": "function (doc) {\n    var csl = doc.message;\n\tvar ris = [];\n\n    var genre = '';\n    \n    switch (csl.type) {\n      case \"article-journal\":\n      \tgenre = 'JOUR';\n      \tbreak;\n      case \"chapter\":\n      \tgenre = 'CHAP';\n      \tbreak;\n      case \"book\":\n      \tgenre = 'BOOK';\n      \tbreak;\n      default:\n        genre = 'GEN';\n        break;\n    }\n       \n\tris.push('TY  - ' + genre);\n\t\n\tris.push('ID  - ' + doc._id);\n\n\tfor (var i in csl) {\n\t  switch (i) {\n\n\t   case 'title':\n\t\t   var title = '';\n           if (Array.isArray(csl[i])) {\n\t\t     title = csl[i][0];\n\t         } else {\n\t\t\t title = csl[i];\n\t\t   }\t\t\n   \t\t   ris.push('TI  - ' + title);\n\t\t  break;\n\n\t   case 'author':\n\t\t   for (var j in csl[i]) {\n  \t\t   if (csl[i][j].family && csl[i][j].given) {\n\t\t\t      ris.push('AU  - ' + csl[i][j].family + ', ' + csl[i][j].given);\n\t\t     } else {\n\t\t       ris.push('AU  - ' + csl[i][j].literal);\n\t\t     }\n\t\t   }\n\t\t break;\n\t\t \n\t\tcase 'container-title':\n\t\t   var container = '';\n           if (Array.isArray(csl[i])) {\n\t\t     container = csl[i][0];\n\t         } else {\n\t\t\t container = csl[i];\n\t\t   }\t\t\n\t\t   // need to handle this differently for different types\n   \t\t   ris.push('JO  - ' + container);\n\t\t  break;\n\n\t   case 'volume':\n\t\t ris.push('VL  - ' + csl[i]);\n\t\t break;\n\n\t   case 'issue':\n\t\t ris.push('IS  - ' + csl[i]);\n\t\t break;\n\t \n\t\tcase 'page':\n\t\t  var m = csl[i].match(/(\\d+)-(\\d+)/);\n\t\t  if (m) {\n\t\t\tris.push('SP  - ' + parseInt(m[1]));\n\t\t\tris.push('EP  - ' + parseInt(m[2]));\n\t\t   } else {\n\t\t\t ris.push('SP  - ' + parseInt(csl[i]));\n\t\t   } \n\t\t   break;\n\t \t  \n\t\tcase 'issued':\n\t\t  ris.push('Y1  - ' + csl[i]['date-parts'][0][0]);\n\t\t  break;\n\t  \n\t   case 'DOI':\n\t\t ris.push('DO  - ' + csl[i]);\n\t\t break;\n\t\t \n\t   case 'URL':\n           if (Array.isArray(csl[i])) {\n\t\t     for (var j in csl[i]) {\n\t\t       ris.push('UR  - ' + csl[i][j]);\n\t\t     }\n\t       } else {\n\t\t\t ris.push('UR  - ' + csl[i]);\n\t\t   }\n\t\t   break;\t\t \n\t  \t \n\t\t  default:\n\t\t    break;\n\t    }\n    }\n    ris.push('ER  - ');\n    emit(doc._id, ris.join(\"\\n\"));\n}"
        },
        "ris-by-container": {
            "map": "function (doc) {\n  var csl = doc.message;\n\tvar ris = [];\n\tvar container = 'unknown';\n\n    var genre = '';\n    \n    switch (csl.type) {\n      case \"article-journal\":\n      \tgenre = 'JOUR';\n      \tbreak;\n      case \"chapter\":\n      \tgenre = 'CHAP';\n      \tbreak;\n      case \"book\":\n      \tgenre = 'BOOK';\n      \tbreak;\n      default:\n        genre = 'GEN';\n        break;\n    }\n       \n\tris.push('TY  - ' + genre);\n\t\n\tris.push('ID  - ' + doc._id);\n\n\tfor (var i in csl) {\n\t  switch (i) {\n\n\t   case 'title':\n\t\t   var title = '';\n           if (Array.isArray(csl[i])) {\n\t\t     title = csl[i][0];\n\t         } else {\n\t\t\t title = csl[i];\n\t\t   }\t\t\n   \t\t   ris.push('TI  - ' + title);\n\t\t  break;\n\n\t   case 'author':\n\t\t   for (var j in csl[i]) {\n  \t\t   if (csl[i][j].family && csl[i][j].given) {\n\t\t\t      ris.push('AU  - ' + csl[i][j].family + ', ' + csl[i][j].given);\n\t\t     } else {\n\t\t       ris.push('AU  - ' + csl[i][j].literal);\n\t\t     }\n\t\t   }\n\t\t break;\n\t\t \n\t\tcase 'container-title':\n\t\t   container = '';\n           if (Array.isArray(csl[i])) {\n\t\t     container = csl[i][0];\n\t         } else {\n\t\t\t container = csl[i];\n\t\t   }\t\t\n\t\t   // need to handle this differently for different types\n   \t\t   ris.push('JO  - ' + container);\n\t\t  break;\n\n\t   case 'volume':\n\t\t ris.push('VL  - ' + csl[i]);\n\t\t break;\n\n\t   case 'issue':\n\t\t ris.push('IS  - ' + csl[i]);\n\t\t break;\n\t \n\t\tcase 'page':\n\t\t  var m = csl[i].match(/(\\d+)-(\\d+)/);\n\t\t  if (m) {\n\t\t\tris.push('SP  - ' + parseInt(m[1]));\n\t\t\tris.push('EP  - ' + parseInt(m[2]));\n\t\t   } else {\n\t\t\t ris.push('SP  - ' + parseInt(csl[i]));\n\t\t   } \n\t\t   break;\n\t \t  \n\t\tcase 'issued':\n\t\t  ris.push('Y1  - ' + csl[i]['date-parts'][0][0]);\n\t\t  break;\n\t  \n\t   case 'DOI':\n\t\t ris.push('DO  - ' + csl[i]);\n\t\t break;\n\t\t \n\t   case 'URL':\n           if (Array.isArray(csl[i])) {\n\t\t     for (var j in csl[i]) {\n\t\t       ris.push('UR  - ' + csl[i][j]);\n\t\t     }\n\t       } else {\n\t\t\t ris.push('UR  - ' + csl[i]);\n\t\t   }\n\t\t   break;\t\t \n\t  \t \n\t\t  default:\n\t\t    break;\n\t    }\n    }\n    ris.push('ER  - ');\n    emit(container, ris.join(\"\\n\"));\n}"
        },
        "jats-xml": {
            "map": "/**\n * XMLWriter - XML generator for Javascript, based on .NET's XMLTextWriter.\n * Copyright (c) 2008-2014 Ariel Flesler - aflesler [a] gmail [d] com | http://flesler.blogspot.com\n * Licensed under BSD (https://raw2.github.com/flesler/XMLWriter/master/LICENSE)\n * @version 1.0.2\n * @author Ariel Flesler\n * http://flesler.blogspot.com/2008/03/xmlwriter-for-javascript.html\n */\n \nfunction XMLWriter( encoding, version ){\n\tif( encoding )\n\t\tthis.encoding = encoding;\n\tif( version )\n\t\tthis.version = version;\n};\n(function(){\n\t\nvar proto = XMLWriter.prototype = {\n\t/* These are the defaults, you don't need to change them on the original code */\n\tencoding:'UTF-8',// what is the encoding\n\tversion:'1.0', //what xml version to use\n\tformatting: 'indented', //how to format the output (indented/none)  ?\n\tindentChar:'\\t', //char to use for indent\n\tindentation: 1, //how many indentChar to add per level\n\tnewLine: '\\n', //character to separate nodes when formatting\n\t/* */\n\t//start a new document, cleanup if we are reusing\n\twriteStartDocument:function( standalone ){\n\t\tthis.close();//cleanup\n\t\tthis.stack = [ ];\n\t\tthis.standalone = standalone;\n\t},\n\t//get back to the root\n\twriteEndDocument:function(){\n\t\tthis.active = this.root;\n\t\tthis.stack = [ ];\n\t},\n\t//set the text of the doctype\n\twriteDocType:function( dt ){\n\t\tthis.doctype = dt;\n\t},\n\t//start a new node with this name, and an optional namespace\n\twriteStartElement:function( name, ns ){\n\t\tif( ns )//namespace\n\t\t\tname = ns + ':' + name;\n\t\t\n\t\tvar node = { n:name, a:{ }, c: [ ] };//(n)ame, (a)ttributes, (c)hildren\n\t\t\n\t\tif( this.active ){\n\t\t\tthis.active.c.push(node);\n\t\t\tthis.stack.push(this.active);\n\t\t}else\n\t\t\tthis.root = node;\n\t\tthis.active = node;\n\t},\n\t//go up one node, if we are in the root, ignore it\n\twriteEndElement:function(){\n\t\tthis.active = this.stack.pop() || this.root;\n\t},\n\t//add an attribute to the active node\n\twriteAttributeString:function( name, value ){\n\t\tif( this.active )\n\t\t\tthis.active.a[name] = value;\n\t},\n\t//add a text node to the active node\n\twriteString:function( text ){\n\t\tif( this.active )\n\t\t\tthis.active.c.push(text);\n\t},\n\t//add plain xml content to the active node without any further checks and escaping\n\twriteXML:function( text ){\n\t\tif( this.active )\n\t\t\tthis.active.c.push(text);\n\t},\n\t//shortcut, open an element, write the text and close\n\twriteElementString:function( name, text, ns ){\n\t\tthis.writeStartElement( name, ns ) //take advantage of the chaining\n\t\t\t.writeString( text )\n\t\t\t.writeEndElement();\n\t},\n\t//add a text node wrapped with CDATA\n\twriteCDATA:function( text ){\n\t\t// keep nested CDATA\n\t\ttext = text.replace(/>>]/g, \"]]><![CDATA[>\");\n\t\tthis.writeString( '<![CDATA[' + text + ']]>' );\n\t},\n\t//add a text node wrapped in a comment\n\twriteComment:function( text ){\n\t\tthis.writeString('<!-- ' + text + ' -->');\n\t},\n\t//generate the xml string, you can skip closing the last nodes\n\tflush:function(){\t\t\n\t\tthis.writeEndDocument();//ensure it's closed\n\t\t\n\t\tvar \n\t\t\tchr = '', num = this.indentation,\n\t\t\tformatting = this.formatting.toLowerCase() == 'indented',\n\t\t\tbuffer = ['<?xml version=\"'+this.version+'\" encoding=\"'+this.encoding+'\"'];\n\t\t\t\n\t\tif( this.standalone !== undefined )\n\t\t\tbuffer[0] += ' standalone=\"'+!!this.standalone+'\"';\n\t\t\n\t\tbuffer[0] += ' ?>';\n\t\t\n\t\tif( this.doctype && this.root )\n\t\t\tbuffer.push('<!DOCTYPE '+ this.root.n + ' ' + this.doctype+'>'); \n\t\t\n\t\tif( formatting ){\n\t\t\twhile( num-- )\n\t\t\t\tchr += this.indentChar;\n\t\t}\n\t\t\n\t\tif( this.root )//skip if no element was added\n\t\t\tformat( this.root, '', chr, buffer );\n\t\t\n\t\treturn buffer.join( formatting ? this.newLine : '' );\n\t},\n\t//cleanup, don't use again without calling startDocument\n\tclose:function(){\n\t\tif( this.root )\n\t\t\tclean( this.root );\n\t\tthis.active = this.root = this.stack = null;\n\t}/*,\n\tgetDocument: window.ActiveXObject \n\t\t? function(){ //MSIE\n\t\t\tvar doc = new ActiveXObject('Microsoft.XMLDOM');\n\t\t\tdoc.async = false;\n\t\t\tdoc.loadXML(this.flush());\n\t\t\treturn doc;\n\t\t}\n\t\t: function(){//W3C\n\t\t\treturn (new DOMParser()).parseFromString(this.flush(),'text/xml');\n\t}*/\n};\n\n//utility, you don't need it\nfunction clean( node ){\n\tvar l = node.c.length;\n\twhile( l-- ){\n\t\tif( typeof node.c[l] == 'object' )\n\t\t\tclean( node.c[l] );\n\t}\n\tnode.n = node.a = node.c = null;\t\n};\n\n//utility, you don't need it\nfunction format( node, indent, chr, buffer ){\n\tvar \n\t\txml = indent + '<' + node.n,\n\t\tnc = node.c.length,\n\t\tattr, child, i = 0;\n\t\t\n\tfor( attr in node.a )\n\t\txml += ' ' + attr + '=\"' + node.a[attr] + '\"';\n\t\n\txml += nc ? '>' : ' />';\n\n\tbuffer.push( xml );\n\t\t\n\tif( nc ){\n\t\tdo{\n\t\t\tchild = node.c[i++];\n\t\t\tif( typeof child == 'string' ){\n\t\t\t\tif( nc == 1 )//single text node\n\t\t\t\t\treturn buffer.push( buffer.pop() + child + '</'+node.n+'>' );\t\t\t\t\t\n\t\t\t\telse //regular text node\n\t\t\t\t\tbuffer.push( indent+chr+child );\n\t\t\t}else if( typeof child == 'object' ) //element node\n\t\t\t\tformat(child, indent+chr, chr, buffer);\n\t\t}while( i < nc );\n\t\tbuffer.push( indent + '</'+node.n+'>' );\n\t}\n};\n\n//add chaining! :)\nfor( var method in proto ){\n\tif( typeof proto[method] == 'function' && !/flush|getDocument/.test(method) ){\n\t\tvar original = proto[method];\n\t\tproto[method] = function(){\n\t\t\targuments.callee._o_.apply(this,arguments);\n\t\t\treturn this;\n\t\t};\n\t\tproto[method]._o_ = original;\n\t}\n}\n\n})();\n\n// module.exports = XMLWriter\n\n\n\nvar CSL = function () {};\n\nCSL.prototype.to_text = function(doc) { \n\tvar text = '';\n  \n   if (doc.message.text_pages) {\n    for (var i in doc.message.text_pages) {\n      text += doc.message.text_pages[i];\n    }\n  }\n  // return text;\n  // encoding.convert breaks 10.1206/3794.1\n  //text = encoding.convert(text, 'UTF-8');\n  \n  // fix stuff\n  text = text.replace(/\\x08/g, ''); \n\n  return text;\n}\n\nCSL.prototype.to_JATS = function(doc) { \n\tvar xml = '';\n\t\n\tvar xw = new XMLWriter('UTF-8');\n\txw.formatting = 'indented'; //add indentation and newlines\n\txw.indentChar = ' '; //indent with spaces\n\txw.indentation = 2; //add 2 spaces per level\n\n\txw.writeStartDocument();\n\txw.writeDocType('PUBLIC \"SYSTEM\" \"jats-archiving-dtd-1.0/JATS-archivearticle1.dtd\"');\n\n\txw.writeStartElement('article');\n\txw.writeAttributeString('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n\txw.writeStartElement('front');\n\tif (doc.message['container-title']) {\n\t  xw.writeStartElement('journal-meta');\n\t  xw.writeStartElement('journal-title-group');\n\n\t  if (Array.isArray(doc.message['container-title'])) {\n\t\txw.writeElementString('journal-title', '<![CDATA[' + doc.message['container-title'][0] + ']]>');\n\t  } else {\n\t\txw.writeElementString('journal-title', '<![CDATA[' + doc.message['container-title'] + ']]>');\n\t  }\n\t  xw.writeEndElement();\n\n\t  if (doc.message.ISSN) {\n\t\tfor (var i in doc.message.ISSN) {\n\t\t  xw.writeElementString('issn', doc.message.ISSN[i]);\n\t\t}\n\t  }\n\n\t  xw.writeEndElement();\n\t}\n\n\txw.writeStartElement('article-meta');\n\n\tif (doc.message.DOI) {\n\t  xw.writeStartElement('article-id');\n\t  xw.writeAttributeString('pub-id-type', 'doi');\n\t  xw.writeString(doc.message.DOI);\n\t  xw.writeEndElement();\n\t}\n  \n\tif (doc.message.HANDLE) {\n\t  xw.writeStartElement('article-id');\n\t  xw.writeAttributeString('pub-id-type', 'handle');\n\t  xw.writeString(doc.message.HANDLE);\n\t  xw.writeEndElement();\n\t}  \n\n\tif (doc.message.PMID) {\n\t  xw.writeStartElement('article-id');\n\t  xw.writeAttributeString('pub-id-type', 'pmid');\n\t  xw.writeString(String(doc.message.PMID));\n\t  xw.writeEndElement();\n\t}\n\n\tif (doc.message.PMC) {\n\t  xw.writeStartElement('article-id');\n\t  xw.writeAttributeString('pub-id-type', 'pmc');\n\t  xw.writeString(doc.message.PMC);\n\t  xw.writeEndElement();\n\t}\n  \n \tif (doc.message['article-number']) {\n\t  xw.writeStartElement('article-id');\n\t  xw.writeAttributeString('pub-id-type', 'publisher-id');\n\t  xw.writeString(doc.message['article-number']);\n\t  xw.writeEndElement();\n\t} \n\n\t// title\t\t\n\txw.writeStartElement('title-group');\n\tif (doc.message.title) {\n\n\t  if (Array.isArray(doc.message.title)) {\n\t\txw.writeElementString('article-title', '<![CDATA[' + doc.message.title[0] + ']]>');\n\t  } else {\n\t\txw.writeElementString('article-title', '<![CDATA[' + doc.message.title + ']]>');\n\t  }\n\t}\n\txw.writeEndElement();\n\n\t// authors\n\tif (doc.message.author) {\n\t  xw.writeStartElement('contrib-group');\n\t  for (var i in doc.message.author) {\n\t\txw.writeStartElement('contrib');\n\t\txw.writeAttributeString('contrib-type', 'author');\n\n\t\tif (doc.message.author[i].ORCID) {\n\t\t\txw.writeStartElement('contrib-id');\n\t\t\txw.writeAttributeString('contrib-id-type', 'orcid');\n\t\t\txw.writeString('https://orcid.org/' + doc.message.author[i].ORCID);\n\t\t\txw.writeEndElement();\n\t\t}\n\n\n\t\txw.writeStartElement('name');\n\t\tif (doc.message.author[i].literal) {\n\t\t  xw.writeElementString('string-name', doc.message.author[i].literal);\n\t\t}\n\t\tif (doc.message.author[i].family) {\n\t\t  xw.writeElementString('surname', doc.message.author[i].family);\n\t\t}\n\t\tif (doc.message.author[i].given) {\n\t\t  xw.writeElementString('given-names', doc.message.author[i].given);\n\t\t}\n\t\txw.writeEndElement();\n\n\t\txw.writeEndElement();\n\t  }\n\t  xw.writeEndElement();\n\t}\n\n\t// date\n\tif (doc.message.issued) {\n\t  var dateparts = doc.message.issued['date-parts'][0];\n\t  xw.writeStartElement('pub-date');\n\n\t  if (dateparts.length >= 1) {\n\t\txw.writeElementString('year', String(dateparts[0]));\n\t  }\n\t  if (dateparts.length >= 2) {\n\t\txw.writeElementString('month', String(dateparts[1]));\n\t  }\n\t  if (dateparts.length == 3) {\n\t\txw.writeElementString('day', String(dateparts[2]));\n\t  }\n\t  xw.writeEndElement();\n\t}\n\n\tif (doc.message.volume) {\n\t  xw.writeElementString('volume', doc.message.volume);\n\t}\n\tif (doc.message.issue) {\n\t  xw.writeElementString('issue', doc.message.issue);\n\t}\n\n\tif (doc.message.page) {\n\t  var delimiter = doc.message.page.indexOf('-');\n\t  if (delimiter != -1) {\n\t\tvar spage = doc.message.page.substring(0, delimiter);\n\t\txw.writeElementString('fpage', spage);\n\t\tvar epage = doc.message.page.substring(delimiter + 1)\n\t\txw.writeElementString('lpage', epage);\n\t  } else {\n\t\txw.writeElementString('fpage', doc.message.page);\n\t  }\n\t}\n\n\n\t// abstract\n\tif (doc.message.abstract) {\n\t\n\t  // do we have multiple languages?\n\t  if (doc.message.multi) {\n\t  \tif (doc.message.multi._key.abstract) {\n\t  \t\n\t  \t   for (var lang in doc.message.multi._key.abstract) {\n\t  \t   \txw.writeStartElement('abstract');\n\t\t\txw.writeAttributeString('xml:lang', lang);\t  \t   \t\n\t\t\txw.writeElementString('p', '<![CDATA[' + doc.message.multi._key.abstract[lang] + ']]>');\n\t  \t  \txw.writeEndElement();\t  \t   \t\n\t  \t   }\n\t  \t}\n\t  } else {\n\t\t  xw.writeStartElement('abstract');\n      \n      var abstract_text = doc.message['abstract'];\n      \n      // fix JATS tags\n      abstract_text = abstract_text.replace(/<jats:p>/g, '<p>');\n      abstract_text = abstract_text.replace(/<\\/jats:p>/g, '</p>');\n      abstract_text = abstract_text.replace(/<jats:italic>/g, ' <i>');\n      abstract_text = abstract_text.replace(/<\\/jats:italic>/g, '</i> ');\n      \n\t\t  xw.writeElementString('p', '<![CDATA[' + abstract_text  + ']]>');\n\t  \t  xw.writeEndElement();\n\t  }\n\t}\n\n\txw.writeEndElement(); // article-meta\n\n\txw.writeEndElement(); // front\n\n\txw.writeStartElement('body');\n\n\t// OCR or PDF text\n  \n  if (doc.message['page-text']) {\n    \n    xw.writeAttributeString('specific-use', 'OCR');\n    \n    for (var i in doc.message['page-text']) {\n        var text = doc.message['page-text'][i];\n        text = text.replace(/\\f/g, '*'); // page break\n        text = text.replace(/\\x07/g, ''); // bell\n        text = text.replace(/\\\\u/g, '\\\\\\\\u'); // avoid \\u being confused as unicode character\n        text = text.replace(/\\\\(\\d+)/g, '\\\\\\\\$1'); // things like \\1 break Javascript\n      \n        text = text.replace(/\\x08/g, '');\n        text = text.replace(/\\x0B/g, '');\n\t\t\t\t//xw.writeElementString('p', '<![CDATA[' + escape(text)  + ']]>');\n        // need to ensue text is UTF-8, which it might not be, e.g. 10.21829/abm85.2008.1072\n        xw.writeElementString('p', '<![CDATA[' + text  + ']]>');\n\t\t\t}\n    \n  }\n  \n  if (doc.message['page-thumbnails']) {\n\t\txw.writeStartElement('supplementary-material');\n\t\txw.writeAttributeString('content-type', 'scanned-pages');\n\n\t\tfor (var i in doc.message['page-thumbnails']) {\n\t\t\txw.writeStartElement('graphic');\n\t\t\txw.writeAttributeString('xlink:href', doc.message['page-thumbnails'][i]);\n\t\t\txw.writeAttributeString('xlink:role', 'thumbnail');\n\t\t\txw.writeAttributeString('xlink:title', i);\n\t\t\txw.writeEndElement();\n\t\t}\n\t\txw.writeEndElement();\n\t}\n\t\n\tif (doc.message['page-images']) {\n\t\txw.writeStartElement('supplementary-material');\n\t\txw.writeAttributeString('content-type', 'scanned-pages');\n\n\t\tfor (var i in doc.message['page-images']) {\n\t\t\txw.writeStartElement('graphic');\n\t\t\txw.writeAttributeString('xlink:href', doc.message['page-images'][i]);\n\t\t\txw.writeAttributeString('xlink:role', 'image');\n\t\t\txw.writeAttributeString('xlink:title', i);\n\t\t\txw.writeEndElement();\n\t\t}\n\t\txw.writeEndElement();\n\t}\n\n  \n  \n  \n\t/*\n\tif (count($reference->text) > 0)\n\t{\n\t\tforeach ($reference->text as $text)\n\t\t{\n\t\t\t$preformat = $body->appendChild($doc->createElement('preformat'));\n\t\t\t$preformat->appendChild($doc->createTextNode($text));\n\t\t}\n\t}\n\t*/\n\n\t\n\t\n\n\txw.writeEndElement(); // body\n\n\txw.writeStartElement('back');\n\n\t// References in CrossRef CSL\n\tif (doc.message.reference) {\n\t  xw.writeStartElement('ref-list');\n\n\t  for (var i in doc.message.reference) {\n\t\txw.writeStartElement('ref');\n\t\txw.writeAttributeString('id', doc.message.reference[i].key);\n\n\t\txw.writeStartElement('mixed-citation');\n\n\t\tif (doc.message.reference[i].unstructured) {\n\t\t  // Note use of CDATA to avoid issues with ampersands\n\t\t  xw.writeString('<![CDATA[' + doc.message.reference[i].unstructured + ']]>');\n\t\t} else {\n\t\t  // some structure\n\t\t  \n\t\t  // {\"key\":\"7295_B26\",\"first-page\":\"63\",\"article-title\":\"On a new species of Rafflesia from Manila.\",\"volume\":\"4\",\"author\":\"Teschemacher\",\"year\":\"1842\",\"journal-title\":\"Boston Journal of Natural History\"}\n\t\t  \n\t\t  var keys = ['author', 'year', 'article-title', 'journal-title', 'volume', 'issue', 'first-page'];\n\t\t  \n\t\t  for (var j in keys) {\n\t\t    if (doc.message.reference[i][keys[j]]) {\n\t\t\t\tswitch (keys[j]) {\n\t\t\t\t\t// keys that map directly to JATS\n\t\t\t\t\tcase 'article-title':\n\t\t\t\t\t\txw.writeElementString(keys[j], '<![CDATA[' + doc.message.reference[i][keys[j]] + ']]>');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase 'volume':\n\t\t\t\t\tcase 'issue':\n\t\t\t\t\tcase 'year':\n\t\t\t\t\t\txw.writeElementString(keys[j], doc.message.reference[i][keys[j]]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t// keys that we need to map \n\t\t\t\t\tcase 'author':\n\t\t\t\t\t\txw.writeStartElement('person-group');\n\t\t\t\t\t\t\txw.writeElementString('string-name', '<![CDATA[' + doc.message.reference[i][keys[j]] + ']]>');\n\t\t\t\t\t\txw.writeEndElement();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase 'journal-title':\n\t\t\t\t\t\txw.writeElementString('source', '<![CDATA[' + doc.message.reference[i][keys[j]] + ']]>');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'first-page':\n\t\t\t\t\t\txw.writeElementString('fpage', doc.message.reference[i][keys[j]]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t  }\n\t\t  \n\t\t  \n\t\t\n\t\t}\n\n\t\tif (doc.message.reference[i].DOI) {\n      \n      var doi = doc.message.reference[i].DOI;\n      doi = doi.replace(/</, '&lt;');\n      doi = doi.replace(/>/, '&gt;');\n      \n\t\t  xw.writeStartElement('ext-link');\n\t\t  xw.writeAttributeString('ext-link-type', \"uri\");\n\t\t  xw.writeAttributeString('xlink:href', \"https://doi.org/\" + doi);\n\t\t  xw.writeAttributeString('xlink:type', \"simple\");\n\t\t  xw.writeString(\"doi:\" + doi);\n\t\t  xw.writeEndElement();\n\t\t}\n\n\t\txw.writeEndElement(); // mixed-citation\n\n\t\txw.writeEndElement(); // ref\n\t  }\n\n\t  xw.writeEndElement(); // ref-list\n\t}\n\n\txw.writeEndElement(); // back\n\n\txw.writeEndElement(); // article\n\txw.writeEndDocument();\n\n\tvar xml = xw.flush(); //generate the xml string\n\txw.close(); //clean the writer\n\txw = undefined; //don't let visitors use it, it's closed\n\t\n\treturn xml;\n}\n\n//module.exports = CSL;\n\nfunction (doc) {\n    var xml = CSL.prototype.to_JATS(doc);\n    emit(doc._id, xml);\n}\n\n"
        }
    },
    "language": "javascript"
}